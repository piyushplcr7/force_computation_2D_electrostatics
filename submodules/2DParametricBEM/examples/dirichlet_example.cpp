#include <cassert>
#include <cmath>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <limits>
#include <string>

#include "1_9_a.cpp"
#include "dirichlet.hpp"
#include "double_layer.hpp"
#include "parametrized_circular_arc.hpp"
#include "parametrized_fourier_sum.hpp"
#include "parametrized_line.hpp"
#include "parametrized_mesh.hpp"
#include "single_layer.hpp"
#include <Eigen/Dense>
#define _USE_MATH_DEFINES

/**
 * This Function takes a ParametrizedMesh object and outputs another
 * ParametrizedMesh object with the panels being the linear approximations of
 * the original ones.
 *
 * @param pmesh The mesh to be converted
 * @return The converted ParametrizedMesh
 */
parametricbem2d::ParametrizedMesh
convert_to_linear(const parametricbem2d::ParametrizedMesh &pmesh) {
  unsigned N = pmesh.getNumPanels();
  parametricbem2d::PanelVector lmesh;
  for (unsigned i = 0; i < N; ++i) {
    // Making linear panels using the end points of the original panel
    parametricbem2d::ParametrizedLine lpanel(pmesh.getVertex(i),
                                             pmesh.getVertex((i + 1) % N));
    parametricbem2d::PanelVector tmp = lpanel.split(1);
    lmesh.insert(lmesh.end(), tmp.begin(), tmp.end());
  }
  parametricbem2d::ParametrizedMesh plmesh(lmesh);
  return plmesh;
}

int main() {
  double tol = std::numeric_limits<double>::epsilon();
  std::string filename = "neumann_dsk.txt";
  std::ofstream output(filename);
  std::string filename1 = "neumannex_dsk.txt";
  std::ofstream output1(filename1);
  std::string fname = "dirichlet_example.txt";
  std::ofstream dvpout(fname);
  std::cout << "Examples for Dirichlet BVP" << std::endl;
  std::cout << "##########################" << std::endl;
  // Gauss quadrature order
  unsigned order = 16;
  std::cout << "Gauss Quadrature used with order = " << order << std::endl;
  std::cout << std::setw(12) << "numpanels" << std::setw(32) << "DFK"
            << std::setw(32) << "DSK" << std::setw(16) << "IDFK"
            << std::setw(16) << "IDSK" << std::endl;
  std::cout << std::setw(12) << "         " << std::setw(16) << "Av "
            << std::setw(16) << "L2 " << std::setw(16) << "Av " << std::setw(16)
            << "L2 " << std::setw(16) << "pt. " << std::setw(16) << "pt. "
            << std::endl;
  std::cout << std::setw(12) << "#########" << std::setw(16) << "###"
            << std::setw(16) << "################" << std::setw(16) << "####"
            << std::setw(16) << "################" << std::setw(16) << "####"
            << std::setw(16) << "####" << std::endl;

  // Defining the boundary of domain using fourier sum parametrization
  // Coefficients for cosine terms
  Eigen::MatrixXd cos_list(2, 2);
  //cos_list << 0.25, 0.1625, 0, 0;
   cos_list << 1.5, 0, 0, 0;
  // Coefficients for sine terms
  Eigen::MatrixXd sin_list(2, 2);
  //sin_list << 0, 0, 0.375, 0;
   sin_list << 0, 0, 1.5, 0;
  // Parametrized curve for kite shaped boundary
  parametricbem2d::ParametrizedFourierSum curve(Eigen::Vector2d(0,0), cos_list, sin_list, 0,
                                                2 * M_PI);

  // parametricbem2d::ParametrizedCircularArc
  // curve(Eigen::Vector2d(0,0),1.,0,2*M_PI);
  // Point source location
  std::cout << " curve(0) = " << curve(0) << std::endl;
  Eigen::Vector2d source_pt(2, 0);
  // Point source charge
  double q = 1.;

  // Lambda function for the potential generated by  the source charge
  // Can also be used for evaluating the dirichlet trace
  auto potential = [&](double x1, double x2) {
    Eigen::Vector2d x(x1, x2); // Target point
    // Distance between source and target point
    double dist = (x - source_pt).norm();
    // Assertion required as potential not defined at x = source_pt
    assert(dist > 1e-9);
    // return -1. / 2. / M_PI * log(dist) * q;
    // return sin(x1 - x2) * sinh(x1 + x2);
    return x1 + x2 ;
  };

  // Lambda function for evaluating the Neumann Trace
  auto Tn = [&](const parametricbem2d::AbstractParametrizedCurve &gamma,
                double t) {
    Eigen::Vector2d x = gamma.operator()(t);
    // Getting the tangent vector to evaluate normal
    Eigen::Vector2d tangent = gamma.Derivative(t);
    Eigen::Vector2d normal;
    // Outward normal vector assuming anticlockwise curve
    normal << tangent(1), -tangent(0);
    // Normalizing the normal vector
    normal /= normal.norm();
    double dotprod =
        (source_pt - x).dot(normal) / (source_pt - x).squaredNorm();
    // Neumann trace
    Eigen::VectorXd grad_u(2); // gradient of u
    double X1 = x(0), X2 = x(1);
    grad_u << std::sin(X1 - X2) * std::cosh(X1 + X2) +
                  std::cos(X1 - X2) * std::sinh(X1 + X2),
        std::sin(X1 - X2) * std::cosh(X1 + X2) -
            std::cos(X1 - X2) * std::sinh(X1 + X2);
    // return 1. / 2. / M_PI * dotprod * q;
    // return grad_u.dot(normal);
    return normal(0)+normal(1);
  };

  // Evaluation point for indirect solutions
  Eigen::Vector2d eval_pt(0, 0);

  unsigned maxpanels = 200;

  QuadRule qrr = getGaussQR(order);
  // Loop over number of panels
  for (unsigned numpanels = 5; numpanels <= maxpanels; numpanels += 1) {
    // Making a ParametrizedMesh object
    parametricbem2d::ParametrizedMesh mesh(curve.split(numpanels));
    // parametricbem2d::ParametrizedMesh lmesh = convert_to_linear(mesh);
    // Getting the panels
    using PanelVector = parametricbem2d::PanelVector;
    PanelVector panels = mesh.getPanels();

    if (!true) {
      for (unsigned i = 0; i < numpanels; ++i) {
        for (unsigned j = 0; j < numpanels; ++j) {
          parametricbem2d::ContinuousSpace<1> cont;
          parametricbem2d::DiscontinuousSpace<0> discont;
          Eigen::MatrixXd cont_m =
              parametricbem2d::double_layer::InteractionMatrix(
                  *panels[i], *panels[j], cont, cont, qrr);
          Eigen::MatrixXd maa = cont_m.colwise().sum();
          Eigen::MatrixXd discont_m =
              parametricbem2d::double_layer::InteractionMatrix(
                  *panels[i], *panels[j], cont, discont, qrr);
          // std::cout <<"i,j:"<<i << ","<< j <<"error:
          // "<<(maa-discont_m).norm() << std::endl;
          if (!((maa - discont_m).norm() / discont_m.norm() < 10 * tol)) {
            std::cout << "reduced: \n" << maa << std::endl;
            std::cout << "discont: \n" << discont_m << std::endl;
            std::cout << "i,j " << i << "," << j << " err eps: "
                      << (maa - discont_m).norm() / discont_m.norm() / tol
                      << std::endl;
          }
          // assert((maa-discont_m).norm()/discont_m.norm()<10*tol);
        }
      }
    }
    /////////////
    /*BoundaryMesh bmesh = createMeshwithGamma(curve, numpanels);
    Eigen::MatrixXd galerkinold;
    computeW(galerkinold, bmesh, 0);
    parametricbem2d::ContinuousSpace<1> g_interpol_space;
    // Computing W matrix
    Eigen::MatrixXd W =
        parametricbem2d::hypersingular::GalerkinMatrix(mesh, g_interpol_space,
    order); std::cout << "W error: " << (W-galerkinold).norm() << std::endl;*/
    /////////////

    /////////////
    // Same trial and test spaces
    /*parametricbem2d::ContinuousSpace<1> trial_space;
    parametricbem2d::ContinuousSpace<1> test_space;
    // Space used for interpolation of Dirichlet data
    parametricbem2d::ContinuousSpace<1> g_interpol_space;
    // Computing W matrix
    Eigen::MatrixXd W =
        parametricbem2d::hypersingular::GalerkinMatrix(mesh, g_interpol_space,
    order);
    // Computing K' matrix
    Eigen::MatrixXd Kp =
        parametricbem2d::adj_double_layer::GalerkinMatrix(mesh, trial_space,
    test_space, order);
    // Computing mass matrix
    Eigen::MatrixXd M = parametricbem2d::MassMatrix(mesh, test_space,
    trial_space, order);
    // Getting Dirichlet data
    Eigen::VectorXd delta = g_interpol_space.Interpolate(potential, mesh);*/
    /////////////

    // Solving the Dirichlet Problem using direct first kind method
    // Getting the estimated Neumann Traces from the solver
    Eigen::VectorXd Tn_dfk =
        parametricbem2d::dirichlet_bvp::direct_first_kind::solve(
            mesh, potential, order);

    Eigen::VectorXd tndfkaug(maxpanels);
    Eigen::VectorXd app = Eigen::VectorXd::Constant(maxpanels-numpanels,0);
    tndfkaug << Tn_dfk, app;
    output << tndfkaug.transpose() << std::endl;

    // Solving the Dirichlet Problem using direct first second method
    // Getting the estimated Neumann Traces from the solver
    /*Eigen::VectorXd dsk_sol =
        parametricbem2d::dirichlet_bvp::direct_second_kind::solve(
            mesh, potential, order);
    Eigen::VectorXd Tn_dsk = dsk_sol.segment(0,numpanels);

    Eigen::VectorXd tndskaug(maxpanels);
    Eigen::VectorXd app = Eigen::VectorXd::Constant(maxpanels-numpanels,0);
    tndskaug << Tn_dsk, app;
    output << tndskaug.transpose() << std::endl;*/

    // Solving the Dirichlet Problem using indirect first kind method
    /*Eigen::VectorXd sol_idfk =
        parametricbem2d::dirichlet_bvp::indirect_first_kind::solve(
            mesh, potential, order);

    // Solving the Dirichlet Problem using indirect second kind method
    Eigen::VectorXd sol_idsk =
        parametricbem2d::dirichlet_bvp::indirect_second_kind::solve(
            mesh, potential, order);*/

    // Trial space used in direct first kind method
    /*parametricbem2d::DiscontinuousSpace<0> space;
    // Evaluating the V matrix for calculating av error norm
    Eigen::MatrixXd V00 =
        parametricbem2d::single_layer::GalerkinMatrix(mesh, space, order);*/

    // Trial space used in direct second kind method
     parametricbem2d::ContinuousSpace<1> space2;
    // Evaluating the V matrix for calculating av error norm
    //Eigen::MatrixXd V11 =
    //    parametricbem2d::single_layer::GalerkinMatrix(mesh, space2, order);

    //Eigen::MatrixXd M11 = MassMatrix(mesh, space2, space2, order);
    // Eigen::MatrixXd M00 = MassMatrix(mesh, space, space, order);

    // Evaluating exact Neumann Traces at mid point of parameter range
    Eigen::VectorXd Tn_ex(numpanels);
    for (unsigned i = 0; i < numpanels; ++i)
      Tn_ex(i) = Tn(*panels[i], 0.);

    Eigen::VectorXd tndfkaug1(maxpanels);
    Eigen::VectorXd app1 = Eigen::VectorXd::Constant(maxpanels-numpanels,0);
    tndfkaug1 << Tn_ex, app1;
    output1 << tndfkaug1.transpose() << std::endl;

    /*Eigen::VectorXd Tn_ex0(numpanels);
    for (unsigned i = 0; i < numpanels; ++i)
      Tn_ex0(i) = Tn(*panels[i], -1.);

    Eigen::VectorXd tndskaug1(maxpanels);
    Eigen::VectorXd app1 = Eigen::VectorXd::Constant(maxpanels-numpanels,0);
    tndskaug1 << Tn_ex0, app1;
    output1 << tndskaug1.transpose() << std::endl;*/

    // Evaluating the errors
    // Direct First Kind
    double err_dfk =
        0; //((0.5 * M + K)*delta - V * Tn_ex).lpNorm<Infinity>();//fabs((Tn_ex
           //- Tn_dfk).transpose().dot(V00 * (Tn_ex - Tn_dfk))); // av norm

    double err_dfk_2 =
        0; //(- W*delta + (0.5*M-Kp)* Tn_ex0 ).lpNorm<Infinity>();//fabs((Tn_ex
           //- Tn_dfk).transpose().dot(M00 * (Tn_ex - Tn_dfk))); // L2 norm

    // Direct Second Kind
    double err_dsk = 0; // fabs((Tn_ex0 - Tn_dsk).transpose().dot(V11 * (Tn_ex0
                        // - Tn_dsk))); // av norm

    double err_dsk_2 =  0;//fabs((Tn_ex0 - Tn_dsk).transpose().dot(M11 * (Tn_ex0 - Tn_dsk))); // L2 norm

    double err_idfk = 0; // fabs(potential(eval_pt(0), eval_pt(1)) -
                         // parametricbem2d::single_layer::Potential(eval_pt,
                         // sol_idfk, mesh, space, order));

    // Indirect Second Kind, point error evaluation
    double err_idsk = 0; // fabs(potential(eval_pt(0), eval_pt(1)) -
                         // parametricbem2d::double_layer::Potential(eval_pt,
                         // sol_idsk, mesh, space, order));

    std::cout << std::setw(12) << numpanels << std::setw(16) << err_dfk
              << std::setw(16) << err_dfk_2 << std::setw(16) << err_dsk
              << std::setw(16) << err_dsk_2 << std::setw(16) << err_idfk
              << std::setw(16) << err_idsk << std::endl;

    dvpout << std::setw(12) << numpanels << std::setw(16) << err_dfk
           << std::setw(16) << err_dfk_2 << std::setw(16) << err_dsk
           << std::setw(16) << err_dsk_2 << std::setw(16) << err_idfk
           << std::setw(16) << err_idsk << std::endl;
  }
  // output.close();
  // dvpout.close();
  return 0;
}
